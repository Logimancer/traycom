//#![windows_subsystem = "windows"] //keeps a console from opening
use windows::{Devices::{
    SerialCommunication::SerialDevice, 
    Enumeration::{
        DeviceInformation, 
        DeviceInformationCollection
        }
    }, 
    Foundation::IAsyncOperation, 
    core::{Error, HSTRING}
};
use async_std::task;
use tray_icon::{
    menu::{Menu, MenuEvent, MenuItem, PredefinedMenuItem}, TrayIconBuilder, TrayIconEvent};
use winit::event_loop::{ControlFlow, EventLoopBuilder};

//Async wrapper for getting device info
pub async fn serial_ports_device_info(
    deviceinformation: IAsyncOperation<DeviceInformationCollection>) 
    -> DeviceInformationCollection {
        let response: Result<DeviceInformationCollection, Error> = 
            deviceinformation.await;
        response.unwrap()
}

//Async wrapper for getting port number
pub async fn deviceport(serial_device: IAsyncOperation<SerialDevice>) 
    -> SerialDevice {
    let response: Result<SerialDevice, Error> = 
        serial_device.await;
    response.unwrap()
}

//Create Device information from SerialDevices
fn get_serial_devices() -> DeviceInformationCollection  {
    let deviceid: windows::core::HSTRING = 
        SerialDevice::GetDeviceSelector().unwrap();
    //Get device information for name
    let deviceinformation: Result<IAsyncOperation<DeviceInformationCollection>, Error> = 
        DeviceInformation::FindAllAsyncAqsFilter(&deviceid);
    let dev_info_collection: DeviceInformationCollection = 
        task::block_on(serial_ports_device_info(
            deviceinformation.unwrap()
        )
    );
    dev_info_collection
}

fn serial_device_comm_number(deviceid: HSTRING) -> windows::core::HSTRING {
    let serial_device_async: Result<IAsyncOperation<SerialDevice>, Error> = 
        SerialDevice::FromIdAsync(&deviceid);
    let serial_device: SerialDevice = 
        task::block_on(
            deviceport(serial_device_async.unwrap()
        )
    );
    let serial_return: HSTRING = serial_device.PortName().unwrap();
    serial_return 
}

fn load_icon(path: &std::path::Path) -> tray_icon::Icon {
    let (icon_rgba, icon_width, icon_height) = {
        let image: image::ImageBuffer<image::Rgba<u8>, Vec<u8>> = image::open(path)
            .expect("Failed to open icon path")
            .into_rgba8();
        let (width, height) = image.dimensions();
        let rgba: Vec<u8> = image.into_raw();
        (rgba, width, height)
    };
    tray_icon::Icon::from_rgba(icon_rgba, icon_width, icon_height).expect("Failed to open icon")
}

fn enumerate_serial_devices(serial_device_information_collection: DeviceInformationCollection) -> 
    Vec<(HSTRING, HSTRING)> {    
    let mut serial_devices:Vec<(HSTRING, HSTRING)> = Vec::new(); 
    for serial_device in serial_device_information_collection {
        let serial_device_id = serial_device_comm_number(
            serial_device.Id().unwrap());
        let serial_device_name = serial_device.Name().unwrap();
        serial_devices.push((serial_device_id, serial_device_name));
    }
    serial_devices
}

fn main() {    
    let serial_devices_information_collection: DeviceInformationCollection = 
    get_serial_devices();


    //setup icon for tray
    let path: &str = "icon\\icon.ico";
    let icon: tray_icon::Icon = load_icon(std::path::Path::new(path));
    
    //build event loop for tray (req'd)
    let event_loop: winit::event_loop::EventLoop<()> = EventLoopBuilder::new().build().unwrap();
    
    //Show comports in menu, iterating through list made above:
        
    //Setup tray menu and tray menu items
    //TODO: make this a function where you pass in the menu struct, it clears it and adds new
    struct MenuItemsStruct {
        menu: Menu,
        number_of_serial_devices: i32,
        refresh_id_number: String,
        quit_id_number: String
    }
    let menu: Menu = Menu::new();    
    fn refresh_menu_ports(menu: Menu, serial_devices_information_collection: DeviceInformationCollection) -> 
        MenuItemsStruct {
        //enumerate serial devices
        let serial_devices: Vec<(HSTRING, HSTRING)> = 
            enumerate_serial_devices(serial_devices_information_collection);
        let mut number_of_serial_devices: i32 = 0;
        let mut menu_items: Vec<MenuItem> = Vec::new();
        for serial_device in serial_devices {
            //iterate through each serial device and add to menu
            //println!("{} {}", serial_device.0, serial_device.1);
            let current_menu_item = serial_device.0.to_string() + " " + &serial_device.1.to_string();
            menu_items.push(MenuItem::new(current_menu_item, false, Option::None));
            number_of_serial_devices = number_of_serial_devices + 1;
        }
        //Add Ports to menu
        for port in menu_items {
            let _ = menu.append(&port);    
        }
        //Seperator definition
        let menu_item_seperator = PredefinedMenuItem::separator();
        //Refresh definition
        let menu_item_refresh = MenuItem::new(
            "Refresh", true, Option::None);
        //Quit definition
        let menu_item_quit: MenuItem = MenuItem::new(
                "Quit", true, Option::None);
        //Add control items after ports to menu
        let _ = menu.append_items(&[&menu_item_seperator, 
                                    &menu_item_refresh,
                                    &menu_item_seperator,
                                    &menu_item_quit]);
        MenuItemsStruct {
            menu: menu, 
            number_of_serial_devices: number_of_serial_devices,
            refresh_id_number: menu_item_refresh.id().0.to_string(),
            quit_id_number: menu_item_quit.id().0.to_string()
        }
    } 

    //Create initial menu
    let menu_updated = refresh_menu_ports(menu, serial_devices_information_collection);
    println!("menu quit id sting {}", menu_updated.quit_id_number);   
    for item in menu_updated.menu.items().into_iter() {
        println!("{}", item.id().0);
    }
    let number_of_serial_devices_str: String = 
        "Number of ports: ".to_owned() + &menu_updated.number_of_serial_devices.to_string();

    //display tray icon
    let _tray_icon = Some(
        TrayIconBuilder::new()
            .with_menu(Box::new(menu_updated.menu))
            .with_tooltip(&number_of_serial_devices_str) //number of comports on hover
            .with_icon(icon)
            .build()
            .unwrap(),
    );
    let menu_channel = MenuEvent::receiver();
    let tray_channel = TrayIconEvent::receiver();
    let _ = event_loop.run(move |_event: winit::event::Event<()>, 
        event_loop: &winit::event_loop::EventLoopWindowTarget<()>| {
        event_loop.set_control_flow(ControlFlow::Poll);
        if let Ok(event) = tray_channel.try_recv() {
            println!("{event:?}");
        }
        if let Ok(event) = menu_channel.try_recv() {
            println!("{event:?}");
            
            //Refresh action
            if event.id.0 == menu_updated.refresh_id_number {
                for item in menu_updated.menu.items().into_iter() {
                    menu_updated.menu.remove(item.as_menuitem())
                }
            }
            //Quit action
            if event.id.0 == menu_updated.quit_id_number {
               event_loop.exit(); 
            }
        }
    });
} 